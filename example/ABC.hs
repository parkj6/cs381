module ABC where


-- 1. Determine whether each string can be generated by the above grammar.
--    If the string can be generated, determine which non-terminal (A, B, or C)
--    you must start with in order to generate it. In each blank, write either
--    A, B, or C if the string can be generated, or write "no" if it cannot be
--    generated.
-- 
--    a. A
--    b. B
--    c. no
--    d. A
--    e. C
--    f. no
--    g. B
--    h. no
--    i. B
--    j. B


-- 2. Implement the grammar as a Haskell data type.

data A = OAO A 
       | IBI B

data B = BBC B B C 
       | O

data C = CCC C C C 
       | I

-- Note that you can choose whatever names you like for the data constructors.
-- I chose them to look like the original rules, using O and I for 0 and 1.
-- To help see the relationship to the original grammar, it helps to see what
-- the corresponding pretty printers looks like. Recall that pretty printers
-- translate from abstract syntax to concrete syntax.

-- | Pretty printer for A.
prettyA :: A -> String
prettyA (OAO a) = "0" ++ prettyA a ++ "0"
prettyA (IBI b) = "1" ++ prettyB b ++ "1"

-- | Pretty printer for B.
prettyB :: B -> String
prettyB (BBC b1 b2 c) = prettyB b1 ++ prettyB b2 ++ prettyC c
prettyB O             = "0"

-- | Pretty printer for C.
prettyC :: C -> String
prettyC (CCC c1 c2 c3) = prettyC c1 ++ prettyC c2 ++ prettyC c3
prettyC I              = "1"


-- For each string that can be produced by the grammar:
--   (a) write the corresponding Haskell value
--   (b) draw the corresponding abstract syntax tree
--       (using the Haskell data constructors as nodes).


-- Note that these solutions are not necessarily unique!


-- | 
--   >>> prettyA exA
--   "101"
exA :: A
exA = IBI O

-- | 
--   >>> prettyB exB
--   "00111"
exB :: B
exB = BBC O O (CCC I I I)

-- exC is not possible

-- | 
--   >>> prettyA exD
--   "0100110"
exD :: A
exD = OAO (IBI (BBC O O I))

-- | 
--   >>> prettyC exE
--   "11111"
exE :: C
exE = CCC (CCC I I I) I I

-- exF is not possible

-- | 
--   >>> prettyB exG
--   "0010111"
exG :: B
exG = BBC (BBC O O I) O (CCC I I I)

-- exH is not possible

-- | 
--   >>> prettyB exI
--   "0000111"
exI :: B
exI = BBC O (BBC O (BBC O O I) I) I

-- | 
--   >>> prettyB exJ
--   "0011101"
exJ :: B
exJ = BBC (BBC O O (CCC I I I)) O I
